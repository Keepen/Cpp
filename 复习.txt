Question 1
一.string、vector

1.string和vector的iterator使用什么方式实现的
2.string库中append函数功能
3.string库中都有哪些查找函数？他们时如何进行查找的？
4.vector中，reserve函数的功能是什么？如何实现？
5.vector库中，insert和erase函数为什么会导致迭代器失效？
6.string和vector库中中at函数功能是什么？和[]的区别是什么？


Answer 1
一.string、vector

1.	原生指针
2.	追加字符串，和+=类似；有其他重载方式
3.	find，rfind；find顺找，rfind逆找；find_first_of，find_last_of
4.	扩容，重分配；  
5.	insert：若其导致扩容才会失效；
	erase：本身不导致失效，某些版本强制使其失效；
6.	功能：与[]类似；
	at会抛出一个越界错误；[]越界直接崩溃。

Question 2
二.list

1.list的底层结构？
2.list的迭代器有哪些功能？怎么实现？
3.list的迭代器失效是有那个函数导致的？为何？

Answer 2
二.list

1.	带头双向循环链表
2.	类似指针，提供解引用、箭头、++、--、==、!=等；由于是不连续空间，所以没有提供
	类似原生指针的+、-、>、<等方法。实现方式是封装了一个包含链表指针的类，
	然后重载对应运算符实现的
3.	erase，因为erase一定会导致当前节点被释放掉	


Question 3
三.deque、stack、queue

1.简述deque的迭代器是怎么实现的
2.简述stack和queue的功能
3.stack和queue为什么选择deque作为自己的底层默认容器
4.简述priority_queue是什么？
5.什么是仿函数？它有什么应用？
6.stack和queue除了使用deque还可以使用何种容器实现？


Answer
三.deque、stack、queue

1.	有四个指针：
	1）所在元素位置
	2）所在缓冲区尾指针
	3）所在缓冲区的尾指针
	4）map中当前缓冲区所在位置的指针（二级指针）
	（重载+ - > < []等完全模拟指针的迭代器）
2.	stack先入后出；queue先入先出
3.	deque是在双端进行插入/删除最快的容器；
	而stack和queue只有双端的插入/删除需求
4.	堆，模拟实现了堆的功能：创建、插入、删除等
5.	重载了()的类。
	1）在sort函数、priority_queue容器中，作为排序的准则。
	2）在类模板中，需要由用户定义的方法时，可以将仿函数（类型）写在
		template列表内。用户通过仿函数的传入决定程序的行为。
	3）lambda表达式的底层实现
6.	stack：vector/list； queue：list（不能用vector -- 不能头插/删）










Question 4
四.map、set、红黑树

1.简述map的[]重载
2.什么是AVL树
3.什么是红黑树
4.如何在红黑树中插入一个元素
5.map的迭代器是如何实现的

Answer 4
四.map、set、红黑树
1.	如果[]内的key不存在，则插入该key的值，将对应的val的引用返回，
	以供赋值；若[]内的key不存在，则直接返回对应的val的引用。
2.	特殊的二叉搜索树：每个节点有记录平衡因子的元素，当平衡因子的绝对值超过1，执行旋转操作。
3.	特殊的二叉搜索树：红节点不能相连，从根到叶子，每条路径上的黑节点数目是相同的。
	这样能保证每个节点的左右子树相对平衡（极端情况，左右差1倍）
4.	五种情况：
	1）空的：直接插
	2）父黑：直接插
	3）父红 && 叔红：叔叔父亲全变黑，爷爷变红，向上重复此过程
	4）父红 && 叔黑：我跟爸爸一条线（左孩子）：右旋，父节点变成新的根，原来爷爷变成新根的右孩子--变红
	5）父红 && 叔黑：我跟爸爸扭一扭（爸爸是爷爷的左孩子，我是爸爸的右孩子），先左旋，变成 4）

5.	找他的后继节点：若该节点有右子树，则找到右子树中最左端的节点即后继节点；
	若没有右子树，看自己是不是爸爸的左孩子，若是，则爸爸是自己的后继节点；
	若不是，则继续向上遍历，直到某个节点是其爸爸的左孩子，则该节点就是后继节点；
	若找到根都没有找到，则自己就是最后一个节点
6.	先看看我是不是叶子，若是：那么直接删除，再看我是不是只有一个孩子，若是：



Question 5
五.哈希
1.简述闭散列是如何处理哈希冲突的
2.简述开散列的结构
3.简述位图
4.简述布隆过滤器
5.若构建的哈希表中，哈希冲突过多，那应该怎么优化？

Answer 5
五.哈希
1.	线性探测：一旦发生冲突，那么就向后查找第一个没有被占用的位置，放上去。
2.	链表数组：数组每个元素都是一个链表头
3.	位图：用位处理的哈希
4.	可以将一些要求精准率不那么高的数据，每一条通过N个哈希函数放在一个位图里面
5.	修改哈希函数



容器适配器：新的容器是通过对现有的容器进行封装得到的。
	比如：	stack/queue -- deque封装实现(头尾插入删除最快)	
			priority_queue（堆） -- vector封装实现
			
map/set底层实现 -- 红黑树
unordered_map/unordered_set: 哈希

